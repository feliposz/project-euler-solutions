"""Problem 61
16 January 2004

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
numbers are all figurate (polygonal) numbers and are generated by the
following formulae:

Triangle        P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
Square          P4,n=n2             1, 4, 9, 16, 25, ...
Pentagonal      P5,n=n(3n1)/2       1, 5, 12, 22, 35, ...
Hexagonal       P6,n=n(2n1)         1, 6, 15, 28, 45, ...
Heptagonal      P7,n=n(5n3)/2       1, 7, 18, 34, 55, ...
Octagonal       P8,n=n(3n2)         1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

  1. The set is cyclic, in that the last two digits of each number is
     the first two digits of the next number (including the last number
     with the first).

  2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
     and pentagonal (P5,44=2882), is represented by a different number
     in the set.

  3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for
which each polygonal type: triangle, square, pentagonal, hexagonal,
heptagonal, and octagonal, is represented by a different number in the
set.
"""

from eulerlib import triangleNum, squareNum, pentagonalNum
from eulerlib import hexagonalNum, heptagonalNum, octagonalNum
from eulerlib import generateListPermutations

def generateNums(function, lower, upper):
    """Apply function to 1-... generating a list of elements within
    'lower' and 'upper' limits (inclusive)."""
    
    print("Generating list for function " + function.__name__)
    numList = []
    i = 0
    num = 0
    while num <= upper:
        num = function(i)
        if num >= lower and num <= upper:
            numList.append(num)
        i += 1
    return numList

def reduceCombinations(currentCombos, nextElementList):
    """Returns a reduced version of currentCombos with an appropriate
    combination from nextElementList, checking the last elements in
    each list in currentCombos, against the first 2 digits in each
    element in nextElementList."""
   
    newCombos = []
    for currentList in currentCombos:
        for nextElement in nextElementList:
            if str(currentList[-1])[-2:] == str(nextElement)[:2]:
                #print(currentList, nextElement)
                newCombos.append(currentList + [nextElement])
    return newCombos

def euler61():
    """Solve problem 61 from Project Euler."""
    
    LOWER = 1000
    UPPER = 9999
    triangles = generateNums(triangleNum, LOWER, UPPER)
    squares = generateNums(squareNum, LOWER, UPPER)
    pentagonals = generateNums(pentagonalNum, LOWER, UPPER)
    hexagonals = generateNums(hexagonalNum, LOWER, UPPER)
    heptagonals = generateNums(heptagonalNum, LOWER, UPPER)
    octagonals = generateNums(octagonalNum, LOWER, UPPER)

    print("triangles =", len(triangles))
    print("squares =", len(squares))
    print("pentagonals =", len(pentagonals))
    print("hexagonals =", len(hexagonals))
    print("heptagonals =", len(heptagonals))
    print("octagonals =", len(octagonals))

    # A list of lists, used for testing the chains
    lists = [triangles, squares, pentagonals, hexagonals, heptagonals, octagonals]

    # Generate all possible permutations for the order of tests
    print("Generating permutations")
    orderPerm = generateListPermutations(list(range(len(lists))))

    print("Permutations = ", len(orderPerm))

    # Make the generated orders as cycles (add first element at the tail)
    print("Making cycles")
    for i in range(len(orderPerm)):
        orderPerm[i].append(orderPerm[i][0])

    # Test all possible order combinations
    for order in orderPerm:

        # A list of candidate lists containing only the first element
        candidates = []
        for element in lists[order[0]]:
            candidates.append([element])

        # Successively filter the candidates adding valid elements to it
        for nextElement in order[1:]:
            candidates = reduceCombinations(candidates, lists[nextElement])

        # Check if a proper cycle was generated
        found = False
        for cycle in candidates:
            if cycle[0] == cycle[-1]:
                print(cycle)
                print(" ".join(map(lambda x: "P" + str(x+3), order)))
                print(sum(cycle[:-1]))
                found = True

        if found:
            break

if __name__ == "__main__":
    euler61()

